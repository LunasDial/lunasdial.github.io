<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring AOP实现原理</title>
      <link href="/2022/10/25/Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2022/10/25/Spring%20AOP%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p><p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p><p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p><h2 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h2><p>AOP用来封装横切关注点，具体可以在下面的场景中使用:</p><p>Authentication 权限<br>Caching 缓存<br>Context passing 内容传递<br>Error handling 错误处理<br>Lazy loading 懒加载<br>Debugging 调试<br>logging, tracing, profiling and monitoring 记录跟踪 优化 校准<br>Performance optimization 性能优化<br>Persistence 持久化<br>Resource pooling 资源池<br>Synchronization 同步<br>Transactions 事务</p><h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p><p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p><p>通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</p><p>切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p><p>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p><p>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p><p>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p><p>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p><h2 id="Spring-AOP组件"><a href="#Spring-AOP组件" class="headerlink" title="Spring AOP组件"></a>Spring AOP组件</h2><p>下面这种类图列出了Spring中主要的AOP组件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2914638/1657724161470-49a095cb-a33f-41ca-b5f5-aac0d85ffe26.png#clientId=ud036dd97-f0e6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u54405c7d&margin=%5Bobject%20Object%5D&originHeight=1770&originWidth=2206&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ubadab4c3-ec98-4ec5-aba0-015ad35da54&title="></p><h2 id="如何使用Spring-AOP"><a href="#如何使用Spring-AOP" class="headerlink" title="如何使用Spring AOP"></a>如何使用Spring AOP</h2><p>可以通过配置文件或者编程的方式来使用Spring AOP。</p><p>配置可以通过xml文件来进行，大概有四种方式：</p><ol><li><pre><code>   配置ProxyFactoryBean，显式地设置advisors, advice, target等</code></pre></li><li><pre><code>   配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</code></pre></li><li><pre><code>   通过&lt;aop:config&gt;来配置</code></pre></li><li><pre><code>   通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</code></pre></li></ol><p>也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</p><p>具体使用的示例可以google. 这里略去</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Java内存区域与内存溢出异常</title>
      <link href="/2022/10/25/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%E6%A8%A1%E5%BC%8F%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/10/25/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy%E6%A8%A1%E5%BC%8F%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1.代理模式"></a>1.代理模式</h1><p>代理模式是常用的java设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。</p><h1 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h1><p>简单来说代理模式就是将被代理类包装起来然后重新实现相同的方法，并且调用原来方法的同时可以在方法前后添加一个新的处理。而这种包装可以使用<strong>继承</strong>或者<strong>组合</strong>来使用。当我们调用的时候需要使用的是代理类的对象来调用而不是原来的被代理对象。<br>静态代理有两种实现方式：</p><ol><li>通过继承实现</li><li>通过组合实现</li></ol><h2 id="2-1通过继承实现静态代理"><a href="#2-1通过继承实现静态代理" class="headerlink" title="2.1通过继承实现静态代理"></a>2.1通过继承实现静态代理</h2><p>通过继承被代理对象，重写被代理方法，可以对其进行代理。<br><strong>优点</strong>：被代理类无需实现接口<br><strong>缺点</strong>：只能代理这个类，要想代理其他类，需要写新的代理方法。<br><strong>cglib动态代理</strong>就是采用这种方式对类进行代理。不过类是由cglib帮我们在内存中动态生成的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving cla....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ProxyTank</span>().move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyTank</span> <span class="keyword">extends</span> <span class="title class_">Tank</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前...&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2-通过组合实现静态代理"><a href="#2-2-通过组合实现静态代理" class="headerlink" title="2.2 通过组合实现静态代理"></a>2.2 通过组合实现静态代理</h2><p>定义一个 Movable 接口被代理类需要和代理类都需要实现该接口。(接口在这里的目的就是起一个<strong>规范作用</strong>保证被代理类和代理类都实现了move()方法)。代理类需要将该接口作为属性，实例化时需要传入该接口的对象，这样该代理类就可以实现代理所有实现Movable的类了。<br><strong>优点</strong>：可以代理所有实现接口的类。<br><strong>缺点</strong>：被代理的类必须实现接口。<br><strong>JDK动态代理</strong>就是采用的这种方式实现的。同样的代理类是由JDK自动帮我们在内存生成的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">implements</span> <span class="title class_">Movable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving cla....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">tank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LogProxy</span>(tank).move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogProxy</span> <span class="keyword">implements</span> <span class="title class_">Movable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Movable movable;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogProxy</span><span class="params">(Movable movable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movable = movable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前....&quot;</span>);</span><br><span class="line">        movable.move();</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3.动态代理"></a>3.动态代理</h3><p>动态代理其实本质还是 将被代理类包装一层，生成一个具有新的相同功能的代理类。<br>但是与静态代理不同的是，这个<strong>代理类</strong>我们自己定义的。而动态代理这个代理类是根据我们的提示<strong>动态生成</strong>的。<br><strong>相比于静态代理，动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。</strong><br>实现动态代理有几种方案：</p><ol><li>JDK动态代理</li><li>CGLIB动态代理</li><li>SpringAOP</li></ol><h2 id="3-1-JDK动态代理"><a href="#3-1-JDK动态代理" class="headerlink" title="3.1 JDK动态代理"></a>3.1 JDK动态代理</h2><p>通过java提供的Proxy类帮我们创建代理对象。<br><strong>优点</strong>：可以生成所有实现接口的代理对象<br><strong>缺点</strong>：JDK反射生成代理必须面向接口, 这是由Proxy的内部实现决定的。生成代理的方法中你必须指定实现类的接口，它根据这个接口来实现代理类生成的所实现的接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用jdk的动态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">implements</span> <span class="title class_">Movable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving cla....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">tank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="comment">// reflection 反射 通过二进制字节码分析类的属性和方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//newProxyInstance: 创建代理对象</span></span><br><span class="line">        <span class="comment">// 参数一: 被代理类对象</span></span><br><span class="line">        <span class="comment">// 参数二：接口类对象  被代理对象所实现的接口</span></span><br><span class="line">        <span class="comment">// 参数三：调用处理器。 被调用对象的那个方法被调用后该如何处理</span></span><br><span class="line">        <span class="type">Movable</span> <span class="variable">o</span> <span class="operator">=</span> (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader()</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Movable.class&#125;</span><br><span class="line">                ,<span class="keyword">new</span> <span class="title class_">LogProxy</span>(tank));</span><br><span class="line">        o.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Movable movable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogProxy</span><span class="params">(Movable movable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movable = movable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法:&quot;</span>+method.getName()+<span class="string">&quot;()执行前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(movable, args);  <span class="comment">// 此处相当于 movable.move()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;方法:&quot;</span>+method.getName()+<span class="string">&quot;()执行后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2-cglib动态代理"><a href="#3-2-cglib动态代理" class="headerlink" title="3.2 cglib动态代理"></a>3.2 cglib动态代理</h2><p>CGLib(Code Generate Library) 与JDK动态代理不同的是，cglib生成代理是被代理对象的子类。因此它拥有继承方法实现静态代理的<strong>优点</strong>：不需要被代理对象实现某个接口。<br><strong>缺点</strong>：不能给final类生成代理，因为final类无法拥有子类。<br>使用cglib生成代理类也很简单，只要指定<strong>父类</strong>和<strong>回调方法</strong>即可<br>首先需要引入依赖</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">3.2</span><span class="number">.12</span>&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>(); <span class="comment">// 增强者</span></span><br><span class="line">        enhancer.setSuperclass(Tank.class); <span class="comment">// 指定父类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TimeMethodInterceptor</span>()); <span class="comment">// 当被代理对象的方法调用的时候会调用 该对象的intercept</span></span><br><span class="line">        <span class="type">Tank</span> <span class="variable">tank</span> <span class="operator">=</span> (Tank)enhancer.create();  <span class="comment">// 动态代理的生成</span></span><br><span class="line">        tank.move();  <span class="comment">// 生成之后会调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimeMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生成的类名&quot;</span>+o.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;生成的类的父类&quot;</span>+o.getClass().getSuperclass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前，被代理的方法&quot;</span>+method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        result = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后，被代理的方法&quot;</span>+method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tank</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving clacla....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="SpringAOP使用以及原理"><a href="#SpringAOP使用以及原理" class="headerlink" title="SpringAOP使用以及原理"></a>SpringAOP使用以及原理</h2><h1 id="4-原理理解"><a href="#4-原理理解" class="headerlink" title="4. 原理理解"></a>4. 原理理解</h1><p>jdk动态代理Proxy原理。<br>Proxy.newProxyInstance 根据用户传进来的参数调用 asm来生成Proxy$0这个代理类。并返回一个实现了接口的代理类，用户实际调用时是调用的代理类的move()方法。<br>扩展：asm提供了一套API,java可以通过它来直接操控内存中的字节码文件即.class文件。有人说因为有了反射java成了动态语言可以操控class文件，但其实java是因为有了ASM才可以真正算得上动态语言！因为反射只能拿到类的内部信息和执行，但是ASM可以直接在内存中修改class文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2914638/1657724013375-f72212a3-91e0-4ef0-b53e-e6cd88d8ba5c.png#clientId=u1e36a60e-de7f-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u17359b3f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1221&originWidth=2129&originalType=url&ratio=1&rotation=0&showTitle=false&size=334281&status=done&style=none&taskId=u614ba973-7135-46ea-8bdd-3ab9a3a1021&title=" alt="image.png"><br>为了看清Proxy代理到底帮我们生成了什么,可以执行下面这段代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zxh.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zxh on 2022/1/20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> sun.misc.ProxyGenerator;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tank</span> <span class="keyword">implements</span> <span class="title class_">Movable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Tank moving cla....&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">9000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Tank</span> <span class="variable">tank</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tank</span>();</span><br><span class="line">        <span class="comment">// 1.8以上版本执行这段话</span></span><br><span class="line"><span class="comment">//System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); </span></span><br><span class="line"><span class="comment">// 1.8及1.8以下执行这段话  具体的可以查看ProxyGenerator下的saveGeneratedFiles属性</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>); </span><br><span class="line">        <span class="type">Movable</span> <span class="variable">o</span> <span class="operator">=</span> (Movable)Proxy.newProxyInstance(Tank.class.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Movable.class&#125;,<span class="keyword">new</span> <span class="title class_">LogHandler</span>(tank) );</span><br><span class="line">        o.move();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    Movable movable ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogHandler</span><span class="params">(Movable movable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.movable = movable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method.getName()+<span class="string">&quot;  start.....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(movable, args);  <span class="comment">// 调用被代理对象 相当于tank.move()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;method:&quot;</span>+method.getName()+<span class="string">&quot;  end!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行成功之后会自动生成一个这个文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2914638/1657724047210-ebc611c4-c92b-4c2d-bb1b-cb60c315613c.png#clientId=u1e36a60e-de7f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=394&id=ua57ef60c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=635&originWidth=747&originalType=url&ratio=1&rotation=0&showTitle=false&size=43829&status=done&style=none&taskId=u03721473-8098-4f4f-ae05-08ae690734a&title=&width=463.004150390625" alt="image.png"><br>代码没有仔细研究，不过还是可以很明显的看到生成的这个类实现了Movable方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.zxh.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Movable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">&quot;com.zxh.proxy.Movable&quot;</span>).getMethod(<span class="string">&quot;move&quot;</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM Java内存区域与内存溢出异常</title>
      <link href="/2022/10/25/JVM%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/10/25/JVM%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>对于大多数Java程序员来说，因为有JVM的自动内存管理，所以并不像C++&#x2F;C一样为了每一个new的对象写delete&#x2F;free代码。但是问题也很明显，如果出现了内存上的问题，再加上对虚拟机怎样使用内存的问题没有了解过，则会导致排查、错误、修正的问题将会是意向异常艰难的工作。</p><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。</p><p>如下图：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625317918450-522ae395-ec42-42da-a5a1-35129f759624.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud88e5da1&margin=%5Bobject%20Object%5D&name=1671546-20190427141310333-343604547.png&originHeight=590&originWidth=1005&originalType=binary&ratio=1&rotation=0&showTitle=false&size=40414&status=done&style=none&taskId=u34cf715d-d1c4-4a16-8b9b-70d7ad49383&title=" alt="1671546-20190427141310333-343604547.png"></p><p>这些数据区域各有各自的用途，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>如果学过计算机相关的知识，对<strong>计数器</strong>这个词就会陌生。就如标题所说，它是一个程序计数器。从上图中我们可以看到程序计数器是每个线程独有的，即线程不共享。在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它时程序控制流程的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p><strong>程序计数器</strong>出现的原因也很简单。由于Java虚拟机的多线程是通过多线程轮流切换、分配处理器的执行时间来完成的，所以需要一个用来记录执行位置的计数器，为了保证线程切换后能够恢复到正确的执行位置。这也就是为什么每一条线程都有一个独立的程序计数器。同时也称这类内存区域为“<strong>线程私有</strong>”。</p><p>附加：如果线程执行的是一个Java方法，则这个计数器记录的是在执行的虚拟机字节码指令的地址；如果是执行本地方法(Native)，这个计数器的值为空。同时这个区域也是唯一一个没有规定任何OutOfMemoryError情况的区域。</p><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>还是从上图中看到虚拟机栈对于线程来说是独有的（“线程私有“）。他的生命周期与线程的生命周期相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步到一个栈帧（栈帧是方法运行期很重要的基础数据结构，在第8章虚拟机字节码执行引擎中会讲到）用于存储局部变量表、动态连接、操作数栈、方法出口等信息。（不懂动态连接是什么，可以看看这个<a href="https://blog.csdn.net/qq_39327985/article/details/97682897?spm=1000.2123.3001.4430%EF%BC%89%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9B%B4%E8%87%B3%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E5%B0%B1%E5%AF%B9%E5%BA%94%E7%9D%80%E4%B8%80%E4%B8%AA%E6%A0%88%E5%B8%A7%E5%9C%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E4%B8%AD%E4%BB%8E%E5%85%A5%E6%A0%88%E5%88%B0%E5%87%BA%E6%A0%88%E7%9A%84%E8%BF%87%E7%A8%8B%E3%80%82">https://blog.csdn.net/qq_39327985/article/details/97682897?spm=1000.2123.3001.4430）每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</a></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/2132024/1625317946172-5541183a-5a5f-4706-bfdc-661001686421.jpeg#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9649bc71&margin=%5Bobject%20Object%5D&name=%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-07-03%20174454.jpg&originHeight=437&originWidth=425&originalType=binary&ratio=1&rotation=0&showTitle=false&size=22544&status=done&style=none&taskId=u6e7a9425-bf19-41c4-a74b-7e29e1b00eb&title=" alt="屏幕截图 2021-07-03 174454.jpg"></p><p>对于大多数程序员来说喜欢将内存区域笼统的分为栈内存和堆内存。但是根据第一张图Java虚拟机运行时数据区可以看出这里的”栈”通常指的是虚拟机栈，或者更多情况下的局部变量表部分。</p><p><strong>局部变量表</strong>存放了编译器克制的各种Java基本数据类型、对象引用和returnAddress。</p><p>这些数据类型在局部变量表中的存储空间都以局部变量槽来表示，只有64位长度的long和double会占用两个槽，其余的数据类型只会占用一个槽。因此这块的内存空间在编译期间就分配完成，也就是当进入一个方法时，这个方法需要在栈帧中分配多大的局部空间是完全确定的，在方法运行时不会改变局部变量表的大小，即槽的数量。</p><p>对于这一块，Java虚拟机规范中也规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverflowError的异常；如果Java虚拟机栈容量可以动态扩展，当扩展到一定的时候就会抛出OutOfMemoryError的异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>在第1张图中我们看到除了虚拟机栈，还有一个本地方法栈也是线程私有的。其实它与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是位虚拟机用到的本地（native）方法服务。</p><p>与虚拟机栈一样，本地方法栈也会有深度溢出或者栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError异常。</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>Java堆时被所有线程所共享的一块内存区域。唯一目的时存放对象实例，Java世界里“几乎”所有对象实例都在这里分配内存。</p><p>《 Java 虚拟机规范》中对Java堆的描述时：“所有的对象实例以及数组都应党在堆上分配”，但随着Java语言的发展，这句话也没有那么绝对了。</p><p>Java堆时垃圾收集器管理的内存区域，因此一些资料中它也被称作 <strong>“GC堆”</strong>（<strong>Grabage Collected Heap</strong> 中文翻译 <strong>垃圾堆（笑）</strong> [狗头保命]）。</p><p>从内存回收来看，现代的垃圾回收器大部分都是基于分代收集理论设计的，所以Java堆中经常出现 “新生代” “老年代”  “永久代”  “ Eden 空间” “From Survivor 空间”  “To Survivor 空间”</p><p>在 JDK 7 版本以及 JDK 7 版本之前，堆内存通常被分为下面三部分：</p><p>1.新生代内存（ Young Generation）</p><p>2.老生代内存 （ Young Generation ）</p><p>3.永久代内存（Permanent Generation ）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625317985173-c9c3b121-6e4b-4cd5-a499-fe9765f417e2.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u81cc1cea&margin=%5Bobject%20Object%5D&name=image-20210703200705327.png&originHeight=375&originWidth=747&originalType=binary&ratio=1&rotation=0&showTitle=false&size=117863&status=done&style=none&taskId=uaebe9550-a910-4d3a-aea5-e5c3cc45f6f&title=" alt="image-20210703200705327.png"></p><p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318001841-0ee9ae0c-700e-4085-b137-1c191cad5a8e.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1cefdd94&margin=%5Bobject%20Object%5D&name=image-20210703200730062.png&originHeight=385&originWidth=899&originalType=binary&ratio=1&rotation=0&showTitle=false&size=192998&status=done&style=none&taskId=uff4d01e7-cba9-4bc5-9e29-6be9f0052d5&title=" alt="image-20210703200730062.png"></p><p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p><strong>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值</strong></p><p><strong>动态年龄的计算代码：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint <span class="title function_">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> &#123;</span><br><span class="line">    <span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">uint age = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line"><span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">age++;</span><br><span class="line">&#125;</span><br><span class="line">uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p><p><strong>1.OutOfMemoryError: GC Overhead Limit Exceeded</strong> : 当 JVM 花太多时间执行垃圾回收并且只能回收很少的对空间时，就会发生此错误。</p><p><strong>2. java.lang.OutOfmemoryError: Java heap space</strong> : 假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p><h4 id="方法区和永久代的关系"><a href="#方法区和永久代的关系" class="headerlink" title="方法区和永久代的关系"></a>方法区和永久代的关系</h4><p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p><h4 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318037998-a4538642-1477-49e0-aca1-a8b5317984b4.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc35041df&margin=%5Bobject%20Object%5D&name=image-20210703201610973.png&originHeight=203&originWidth=1094&originalType=binary&ratio=1&rotation=0&showTitle=false&size=190598&status=done&style=none&taskId=u3c0f194d-39e4-4fb2-92ff-88154887c41&title=" alt="image-20210703201610973.png"></p><p>**1.整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。当元空间溢出时会得到如下错误： **<code>**java.lang.OutOfMemoryError: MetaSpace**</code></p><p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p><strong>2.元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <strong><code>**MaxPermSize**</code></strong> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</strong></p><p><strong>3.在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</strong></p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池时方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p><ol><li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li><li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li><li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li></ol><p><strong>提问：JVM 常量池中存储的是对象还是引用呢？</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input&#x2F;Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I&#x2F;O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象的创建过程图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318053444-6274f656-9bd4-493e-814a-4ccdce9ef1ff.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uca136d04&margin=%5Bobject%20Object%5D&name=image-20210703203111078.png&originHeight=234&originWidth=1206&originalType=binary&ratio=1&rotation=0&showTitle=false&size=43395&status=done&style=none&taskId=u509aef6b-26ef-4ec0-b6f7-975d4c9b328&title=" alt="image-20210703203111078.png"></p><h4 id="第一步：类加载检查"><a href="#第一步：类加载检查" class="headerlink" title="第一步：类加载检查"></a>第一步：类加载检查</h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="第二步：分配内存"><a href="#第二步：分配内存" class="headerlink" title="第二步：分配内存"></a>第二步：分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318070121-f71d5a41-5d22-4cb2-8622-40a3fcb76dc2.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uce2d36a0&margin=%5Bobject%20Object%5D&name=image-20210703204010357.png&originHeight=302&originWidth=1320&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49583&status=done&style=none&taskId=u416de1bd-8f17-4298-9d0c-751392e6285&title=" alt="image-20210703204010357.png"></p><h4 id="第四步：设置对象头"><a href="#第四步：设置对象头" class="headerlink" title="第四步：设置对象头"></a>第四步：设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="第五步：执行-init-方法"><a href="#第五步：执行-init-方法" class="headerlink" title="第五步：执行 init() 方法"></a>第五步：执行 init() 方法</h4><p>就是在我们 new 对象的时候所用的构造方法。在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p><ol><li><strong>句柄：</strong>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318108467-553129ae-2f4b-4fcb-9cea-7ed5bf967f5d.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u779346c2&margin=%5Bobject%20Object%5D&name=image-20210703204837824.png&originHeight=448&originWidth=1013&originalType=binary&ratio=1&rotation=0&showTitle=false&size=182277&status=done&style=none&taskId=u04956a85-6e40-4828-a493-0a8ff3d6797&title=" alt="image-20210703204837824.png"></p><ol start="2"><li>**直接指针： **如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318117030-fd480b6d-f862-4898-8718-064ad03e899d.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u42d6662f&margin=%5Bobject%20Object%5D&name=image-20210703204849072.png&originHeight=439&originWidth=1035&originalType=binary&ratio=1&rotation=0&showTitle=false&size=161235&status=done&style=none&taskId=udc680344-1ef7-414b-b735-897b05eaaff&title=" alt="image-20210703204849072.png"><br><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h3 id="String-类和常量池"><a href="#String-类和常量池" class="headerlink" title="String 类和常量池"></a>String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;<span class="comment">//先检查字符串常量池中有没有&quot;abcd&quot;，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向&quot;abcd&quot;&quot;；</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>这两种不同的创建方法是有差别的。</p><ul><li>第一种方式是在常量池中拿对象；</li><li>第二种方式是直接在堆内存空间创建一个新的对象。</li></ul><p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318132159-2633172e-3eb8-4f87-8907-c31bdc6df6f9.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u5bdd122c&margin=%5Bobject%20Object%5D&name=image-20210703205043332.png&originHeight=373&originWidth=676&originalType=binary&ratio=1&rotation=0&showTitle=false&size=137234&status=done&style=none&taskId=udaeef5b6-1379-4f2d-996c-aa0dd7e7339&title=" alt="image-20210703205043332.png"><br><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p><ol><li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li><li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 <code>intern()</code> 方法。<code>String.intern()</code> 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7 之前（不包含 1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7 以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li></ol><p><strong>JDK8 :</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;计算机&quot;</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure><p><strong>字符串拼接：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2; <span class="comment">//在堆上创建的新的对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2021/png/2132024/1625318144115-ac6124e0-321e-4f74-9ee9-bd74a206433f.png#clientId=u5b9e3066-8595-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u20d464cf&margin=%5Bobject%20Object%5D&name=image-20210703205158913.png&originHeight=543&originWidth=849&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83559&status=done&style=none&taskId=u63b7abe6-48d9-45a1-b2aa-c3b6352e810&title=" alt="image-20210703205158913.png"></p><p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p><h3 id="String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-x3D-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong>可以去试试</p><h3 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？</p><p>大佬解释：</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">首先要了解为什么Integer a=1走缓存，而Integer b=333不走缓存：</span><br><span class="line"></span><br><span class="line">自动拆装箱（看字节码就知道了，最终调用的是 valueOf 方法，而这个方法在一定范围内时是走缓存的）。</span><br><span class="line">然后就是为啥要走缓存：</span><br><span class="line"></span><br><span class="line">性能方面。see Integer#valueOf：as this method is likely to yield significantly better space and time performance by caching frequently requested values。</span><br><span class="line">最后是为把啥缓存设置为[-128，127]区间：</span><br><span class="line"></span><br><span class="line">技术规范。JLS7 5.1.7：If the value p being boxed is an integer literal of type int between -128 and 127 inclusive (§3.10.1), or the boolean literal true or false (§3.10.3), or a character literal between &#x27;\u0000&#x27; and &#x27;\u007f&#x27; inclusive (§3.10.4), then let a and b be the results of any two boxing conversions of p . It is always the case that a == b .</span><br><span class="line">性能和资源之间的权衡（当然也可以调整缓存的正向最大值，自己看 IntegerCache 类的实现）。</span><br></pre></td></tr></table></figure><p>想要继续探求，可以去了解一下 <strong>Integer</strong> 类。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建线程的四种方式</title>
      <link href="/2022/10/24/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/10/24/Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="1-继承Thread类实现多线程"><a href="#1-继承Thread类实现多线程" class="headerlink" title="1.继承Thread类实现多线程"></a>1.继承Thread类实现多线程</h2><p>run()为线程类的核心方法，相当于主线程的main方法，是每个线程的入口<br>a.一个线程调用 两次start()方法将会抛出线程状态异常，也就是的start()只可以被调用一次<br>b.native生明的方法只有方法名，没有方法体。是本地方法，不是抽象方法，而是调用c语言方法<br>  registerNative()方法包含了所有与线程相关的操作系统方法<br>c. run()方法是由jvm创建完本地操作系统级线程后回调的方法，不可以手动调用（否则就是普通方法）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">MyThread mThread1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">MyThread mThread2=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">MyThread myThread3=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-覆写Runnable-接口实现多线程，而后同样覆写run-推荐此方式"><a href="#2-覆写Runnable-接口实现多线程，而后同样覆写run-推荐此方式" class="headerlink" title="2.覆写Runnable()接口实现多线程，而后同样覆写run().推荐此方式"></a>2.覆写Runnable()接口实现<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>，而后同样覆写run().推荐此方式</h2><p>a.覆写Runnable接口实现多线程可以避免单继承局限<br>b.当子类实现Runnable接口，此时子类和Thread的代理模式（子类负责真是业务的操作，thread负责资源调度与线程创建辅助真实业务。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">while</span>(count&gt;<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;-当前剩余票数:&quot;</span>+count--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">MyThread Thread1=<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">Thread mThread1=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">Thread mThread2=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">Thread mThread3=<span class="keyword">new</span> <span class="title class_">Thread</span>(Thread1,<span class="string">&quot;线程3&quot;</span>);</span><br><span class="line">mThread1.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">myThread3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread和实现Runnable接口的区别"><a href="#继承Thread和实现Runnable接口的区别" class="headerlink" title="继承Thread和实现Runnable接口的区别"></a>继承Thread和实现Runnable接口的区别</h3><p>a.实现Runnable接口避免多继承局限<br>b.实现Runnable()可以更好的体现共享的概念</p><h2 id="3-覆写Callable接口实现多线程（JDK1-5）"><a href="#3-覆写Callable接口实现多线程（JDK1-5）" class="headerlink" title="3.覆写Callable接口实现多线程（JDK1.5）"></a>3.覆写Callable接口实现多线程（JDK1.5）</h2><p>a.核心方法叫call()方法，有返回值<br>b.有返回值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> count; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="comment">//Thread.yield();</span></span><br><span class="line">System.out.println(Thread.currentThread().getName()+<span class="string">&quot;当前票数：&quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;sale out&quot;</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">Callable&lt;String&gt; callable  =<span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">FutureTask &lt;String&gt;futureTask=<span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">Thread mThread=<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">Thread mThread2=<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">Thread mThread3=<span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line"><span class="comment">//mThread.setName(&quot;hhh&quot;);</span></span><br><span class="line">mThread.start();</span><br><span class="line">mThread2.start();</span><br><span class="line">mThread3.start();</span><br><span class="line">System.out.println(futureTask.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-通过线程池启动多线程"><a href="#4-通过线程池启动多线程" class="headerlink" title="4.通过线程池启动多线程"></a>4.通过线程池启动多线程</h2><p>通过Executor 的工具类可以创建三种类型的普通线程池：</p><h3 id="FixThreadPool-int-n-固定大小的线程池"><a href="#FixThreadPool-int-n-固定大小的线程池" class="headerlink" title="FixThreadPool(int n); 固定大小的线程池"></a>FixThreadPool(int n); 固定大小的线程池</h3><p>使用于为了满足资源管理需求而需要限制当前线程数量的场合。使用于负载比较重的服务器。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ExecutorService ex=Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">ex.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SingleThreadPoolExecutor-单线程池"><a href="#SingleThreadPoolExecutor-单线程池" class="headerlink" title="SingleThreadPoolExecutor :单线程池"></a>SingleThreadPoolExecutor :单线程池</h3><p>需要保证顺序执行各个任务的场景 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ExecutorService ex=Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">ex.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CashedThreadPool-缓存线程池"><a href="#CashedThreadPool-缓存线程池" class="headerlink" title="CashedThreadPool(); 缓存线程池"></a>CashedThreadPool(); 缓存线程池</h3><p>当提交任务速度高于线程池中任务处理速度时，缓存线程池会不断的创建线程<br>适用于提交短期的异步小程序，以及负载较轻的服务器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">ExecutorService ex=Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">ex.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++) &#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName()+j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ex.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程之间的状态，及他们之间的相互转换<br><img src="https://cdn.nlark.com/yuque/0/2022/png/2914638/1657720542776-1fea876c-133e-48bb-a5ea-33b058b20e96.png#clientId=u1a1bbb1f-6c43-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=249&id=ud5e61bc6&margin=%5Bobject%20Object%5D&originHeight=453&originWidth=1326&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1bf7c423-4de7-4e34-be2b-d13df43669b&title=&width=729.9999389648438"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情侣间的一些记录</title>
      <link href="/2022/10/24/hello-world/"/>
      <url>/2022/10/24/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1149b0bcee318f27cd1a9cdeb9060e44a0eb607727f34afad2e48aab63012ce6">1b693c4938223286468132b2f7068bf67a7a8cfd5095d65051ba6e79c15968eb2211648052effa129b53869ad5d884444cdf0cef1f80b0bd9353669cb322f149b67f85a498e959864b7af9a741d2e75e8f242fd03c3eb7038a651959953e5311e26ba737b6845491cb24431d35cec2240633ef0c8c6f36b0d99ddc7cefb8bee84e098207568ece748d6ad123d5d5b12ec0ff06ddbd17b541c2256e8cefb89c441b7b0511b504990b40905659eab8d5cbb5249ff9508ce86dcbc879aaf1dd2deddce0d84bbf49487b359d486ec6d47572a34092e56e0c868b789434f33d41b64a2b98f1550b30e0bdc683fadf00073b250d41a0d831fd53013de5add5deb236f0a5e2035532534332b2ee2596325469a4eb2094656008ada1793a9b2cf5aff06ab3fdeb23a50eb43d7e926b08104dff15a01b929af7496d96862c1977cd7ba82cbf5200ef49461dadedb840582de0d630cc63b872b7c24d5cff1bb828f4b766284e22c73c481e275b0940d1a8d2447e431c9230267f9bb39bdc61d52ab19f49e550f69fbe13ff7e13147d3e2d669f8a8e1ded42a1f34b6031f4f36025e902bc4645eb0c30699b58101cccc0ec17f5ad944827eb12031a78fb0a0a39acb58ceb2878fb57bcc99c1270d23ddfd48b3c1dcca1e3408cf53d3d31c4f6f786e660fb60cd099174a9c994de3b721200b6723c2ff0e99686bca4d674750904e318721077fd611bb2bbd99698014bf98361fc6575e301b360cbb8dbd4b48c2b7026008e871cd30be8eb84eba1622374fd4ddbda679dc6179532d272ec27081dbdcaddc03ca255e96f864a7aa8b6a5bfd7addc46b02330c6039995651333827346fd9aa35917b00ed7d3465c097f3ce7dd401c07c10c94ff022c5d257d608bd205b67e1a8263523c70bf16f184e1eb87ec2a0a25a6c4570677c2ddb82e032c7d3f6c874a6fae6039f597ba0b9639af2afc415b428b2f01aac5077e56366c246970bf4a8cce6205f1b2fdf24a180632defdded0e2c7cc5eb39781e50a339fe9ee07068078f0ee5daf8173ec45371cba4d18511bcda26599f5988ab8a7ffd20f6a3c65d29298a36fcb930de7dff4d9aaedbcb7867267ae0a22f42c90c071b12001af843f12d1df26535db72c7c6461f2f6428270a4e2b292de63dd299d301502ab695a24b46b082a6d2e2a5f5feac2e175f844ed595a9c8daaad4e956cdaa723cf67ee9afe9c790f87047a0072915aeb3b9cdce31cc1a87746ccbdc6ace18c8b4990d91e0a8eeff2c3697436882091b67bf30ab1063414cabaa237ea197b689d07763748c5697faa39f55808bb2a7d8ca0aac8653a3bf6f8546b40eafca600a4c01dc7802d42f35282fe8fb3881d53e555beca4f226a5d7cb456f4ed8061311ece7c60ca13fd8254c690e4df2da2070987d827a0bcde38b8fdf557eb9b423c3eb735abb9982eee37cc1d246fde8ecd5168a249bb29e4e6a527b42492c742f628ee1e238d32614d4f22332830c319f9358889aff51c8faec8dcc48034042aebc839075e209cdf45875273123d91ef710626c34678b2b17f5a570b890d74fc06b4c74c39acf345f42ae93ac40a896b8db75e2e8a132eb149799b979c925da801a04c2b8c4d27ef725c449ac764477221f57a482f30d7871547cf88a96752a0792f24ac4d2ee513cfbf32852c16f7359a0eb0a59e8d3322d95eef90a8542b0f97f17e7da7cdaa37d22aa76f938539018480552de8f6213cf27f98de6b56480a264df1d3a17df53b2e67badba154ac2d880433741e256278be4b481fa41bca5649b3df20db80f96d360dd3f39194e0862ae4a862326cd586226caaddd934225ff17b201b6bee0706b25c5c7f271d01bd373b5f979fb4a6a5c47cf790bc2b34b915eff9a68821934ce19ee898d2d9db5efd6b0443ea53553d836af6b9f51bb0728e35e473b1a1b57b27fe8545b38b83003e2a9e71c06b65b9a2fd8dd32d74b642dbf5154cdd40a092da51583f9299b7751cc16d7b93cf24cf03fdcc23ed39da65431e6bac43e56ee595e3b64e7de4692546314f15e4c27c73001c1769bf034893116e53d136f3dbc6d70852c5d9863626d9b5040e9936b2ba4c647aa100cf705839c5adcacbe489dd4f42974a59f982e751bb8522b808729f0e6dadf1110d267964888fefac3e3310be20c071af308f731ca9bae03e90a698aba8252d2c2652ee57b01b67890ab06ab4d55eb5720ab864e13b8828472d31557dbc2e07a35de6cff5bec15efa668ad3b642e431209d788ca8ce31dc13a10df8e2ba5796d785b40ea97f2f9fddc3235feb93ae02f3e1a77f63af1faf890d4cc268bd846033aea073a9f8e5b8ee8e81bce5b891c0813e1fe75ef6d856a3884b9aae898fa4b73628a5a98e14395831d7ae7864e7b4e9f786497b099b4c63698570758a6a479437c4cb94ea810d98aeedfbf8358c29c46d9cc8c076043d915a6749522d877d10e21f0ed7ed083b603e8cdd342578c91260ec59295cb6dcf440091c926db31bb8af36f54481896445ab3590b013c29c509639e3aa365cfb713ac40fa6d98e243dfaea8c1b56cb27e2e1c1ac619035b033b994294fc7bf2c3d36567a968d0b25590d007eb27b388cef6769aad7d4ce665d5af69263c3002ab844eaf1c9d0bbae913486284262c056ba04c51e6843c9fdbc1e5ea73d75e3837454a3c4129a292ce6cd1f4bfd7470de8e508f3ec7dfe678aaa01ccc8f3fc3c892e5b51f4ee55c6d4db50014197c20a62a76d9a458027e77a223e450bb746d7b9069bdc23c269262af4f9d4c79a84a311547ae2a672b83b0757a8b04cca182fd565f5676b8434a4497bc0632b2feb1b94c947177213e1870bccbc44a90e78d82f832051e8d78d856cbc8612c9cef0a726f0303ba74dd7899991fe6652398b0a5bc6a095420c0efd46af3aed9049c2a30b85a243cfe66ec5344448c22c6abdcbb1af155cdcfc42900d569cab32e58fe27f8fc3c634410c90c70411f7d40039c0fceefe4df77a43a4f261c9ea605518a0d0ea51d641efec8e92ab7cfa5de9e7ed82229a18e5c8e2ff46b76bd7d4149de7b201eac03125d34985e5844046d4e219060d86604a6f5938cb1fd65b00e8abfd10b46f19be56ac425c5c62ba2d995f2f4db6c886a30767f5a4081c70041932fe99cd8018c5f9cd3e0d46e31f6c3f94fbf39c3bc3c6846ef7765834edf8569f2e57affd4c2e7daef508516c4eb70d30e79241cf0b23d8245aef16f075de364af154adccacd171546cf5d1ca5c968b3007377d0d5f5e9ae8692fe5c3b85f20b525592a59ed8c17432fdc179eb4e72965815340097be321289c86c3d8ab5e7037ade45ac3ee9d311d2e8510348b1c06b377f0e0de6cc759048f4f886921dbfd8dacb6ceca24ccf58bc56a77bd4c96b04f0db18cd01c52fbaed441f47b9bedffdb9bbccedb4ee5340f5d0cb87272cb698ac061f30e6790cf1c9ac91c2f0275e110d08adccd53755e68260ac85326a72222472fb22b89435d99916fc74b06cddbd20d5191e3c42d2ae973b10857b1b951f7d884ea27d8652ed4b447f23b508215a96c4106f222d5c38435854a7135cf1876261fb56d82a55ccef80bd68f6f73d542fd26a99748a25112dbec5a871e4482f2adb322c29d1a085f327e9745692d87c56c488fa6dee7073be0bf1356d0a502bc3ceb614fe570c2414fd6f1204637ada457228a85c2994bc41128ec0cba931878b5b4b024538c9c9dd063f0bb0589054742efb3da90682c6be7688c25acc0c21955e6794eb9a910ceb46ff2d9dc524e4f1b3dca5f9550caf36dd98273b3dc0ace8a4e1aa1047ec65e5ea709d15da34c35af7c136fc65fb3b76b4eea88e8ffc46aaae450769897a4ef8f963d2afd82c00eae67545ea3519ab782fd03fad114e5e263703e1ee0636d194b5420434dd052f9ed92a05494771145f27f01f9c1acd0995bfd3e2725b7799a8567bf1e8cf1ea4ff099121decbb6cda56de9c4cf8fa087f56d9ea21f2cdb45fe0fc445755b89ab374b83bb6cdb1c75e83bc969715e0ee19a306b538be9cf5d2d050c082883c7023fa52ec5e32dd916a7b805b9a533b6edd9d0117240b8704b839cc90647954434d3c1c8caceec74617d0a7ec8b4fdfc33ec01ed3e01425cdfdd1824a50c5aa33fa20635d02f497951439caf67cc48675b9b2999abba16e8d609d0225ea4509e2cc19b9c151edff0c1bf8ca20c5495466415e094fcfa73404db846a0097f19d7cb9f59a181fd8def00dca4bf6d9b13452b91bc51a35cb7de70c01ca540c656c50c3a2f2af849fc5f759b163e7e2415c894a361e9ee86960e463696404dfb482b5f133da7476b3297bc9ebb96885d86b8078edce083e09a402a5dd9cff850ad97e6f1033d7e925d4c324257a4c9b6dac0e42db9245205c5b47654b3031fba55d9b32409d07dfc29b5954c4fa8ca4d57d03c8a02c1f49922ed8f11acff49109db3967ae8c71ba5f67ecee28b3362caeadcaa9922d07480bcd172bdd70104a554a22b6e31a909dfbc7cf15d0c23aa7fb4d88227a882f5895cf47b5d22cb085b602251bf420c39e434b834f42b1cf57d1294480478d1538b3a736ce34dfac5808ded62606ee9fb2c37cd1e10f85cf5047aded01e4f7478096f96aab861e3f93ca53e50477d32f2fcf28fe5402254d8fc92a2a8ba68360fa54f7b424665756236fdb051f599832de4e055ba09182c9f64bfcda2163884c34c97564184cba86afb4fec7bb12c18a329eedc49a54514ac77ee3c1173417b06c02060db75749eb25ff34675404d7ccde6366df53de29a7d768ffce3221267b96c192266246596a61e32913435ef7f1300eef81719593768bb0481328c6d5344dc90112489682144340883dd2264ffda06b8e722c700ca29ed521c7ec49b99fe2b588323ffb8139a24d0d1b9a9d356ac838b820adace6348b4b5fdd5535593771a21becb335b4d22f3a7a1af47625dab89b474d3e8fd20d7cff1ab719bafcbd04ec742fa5e87d27e15eb9c670551f6ceaa101b8eed790bf1ed139ce55eb5c6d2554146b1e797d2a444c014cb829acee2d77c65db87604fb4bfcb889c454fa426dc1ce25bcd0931a943d143709f0642995374a817ff41772031ebced48ac33b976acf147383756122007804c5440e6cafbc850c657a652975b2eb8ff8accf266c542e13c9fc6b10a57ea707b4d86910a9b0027e5c2534eda68719a58a9b11e035426acea460faffb3d89e39c97270ec2eaa27f9a3eac032a4bfe4318d562583829590e87185a4358cb1154684dc5649d37985629b66f982e589064bf5165691e8c887769fa1a69d3585fbf2d61093ee8b1a9867b39601bf0c32cb92a49435b22014c5ebe6b00200bd38f8d74e0bd1be1c06c12212532ab3eb423c01b896f4794cad92b0a42a67372c1cb7d6fed0e8eeb6c53227b0ba843805cb8ced9f2d744481bdb0bac537df9491eb0c4a4e9e2c316a4a0a03c27a7c31938d588b07193e92a3e26a2fe5912d4e17411d0a654fd25f27efc4fbd47c5082395e9ac5f045e2f2fa23277668deac0b1ac9125beaa90a14a0f6bc4b9266a35e363102f87ef11901a565094542797423e16d0894388ee684eb45d687b68702387a7acedf21c390cb7c2cb15049775a3be9cd8b0f794ed3bcc4893e3a502d752993bb5dba1804f80713ba27d5c0362dc0b76973b4b0e3708a5089076c7b6e98fa0a5a476b16b37f8205c47524c12eb280628012121dad5dc8860cc87907ac4ecf6d3c4427f33ad89bc3030dfaf9a52e888aba7d1b0f0d9e87604eed4ff8f2ec7c830634a8591721a32ab61950d49667d62a13249adf09d4cc5f3ddd0dbb7ecc505766699f233ad2db84094955158bce837c9f1b79b89d476f2da335b3f81ef6c8a9bc7d5da915bed10a21ed827c3ba8f8ecf539b194800a9854a1ef4e625fcc4cecbc81df5b76fd06106eecbd78c308daf79f463a3eef56b5565e2cec2fdaa2d00344910f159d7d44a0c2df37e8a0b2e29d7784c534a0ba24d63cc8a5c50598542a02422ee462ec24cd89b54c0833a98892ac2e6c69a27fd1447d8df63ee4719f9bcb7f638b1488b8840273fa41758e12b37951115f4ff26dd78161a9593579c23b918ec0aef0632b626d76701c78272b1e36356c16f51ef64170045dcde6ed36cc292a8f0e7f3b50d1dcea597758f58850c1c65e84fa1952eb74afb60de292adde0747b8240a5129003b5c4da461b542561792d0159201399c4f692e4bcbe6c313bbf5327f6c680f22efe6ba0932171b6da9dcc6f704135f823c5764cf5c6daadece008428bb5a7aa0c68e499585d2dcf81ea1415fae876e06c846ea718abd3059687f9585e6051639630e43104eaf5e833751526d81a45b28b46ec3356e780a341f4116f810b8e9ba46cb3657e290c205a97a4069102d719721225a39fd7e74ea7764ede7dd00398e6cc9a36f665cfcdc2566aa29411cfce3da01387d3054ce13c93dd4203bc69e17f17b8cc65cffe9963b5f2fa2c459b53b37681ba4ed7910f36fe557e128318b40caa04568737c1a6f7d6abae06d07b891f314a5b11d98b58fd6234bc57eb864bb619cc9fd51700379d644d066392a9f55f85a60d652cfe80f77c232fe2de4c25c7a76ee9b2aa781e34a9cc6bdf240be8623942ffea726947b668a1ce433a64cd74fb8195519b8aca21b94cb25dc2c7ead3093d6c215cbc8340c21d1781f2e83c2c32a6341fcb4e5665019b019dffc9e80b4f6e5faafde20eadf3d8a4d0f14dc2f0ed3ef8048df71bbaa4bde77c6488c1075a781865808df9ec6816c55c0bfa65d39e544bb2876de015995ddf5593a3f5f14722b3e5ff1127a13ca2bf51383cc58121d480a1ed5774dfcc42aa6a1c4a38761fc776ed550da8f3429d1f74ddcf3820452b5ec3639c51cb866e8e91af10105a35fea9e8ba1fcea30273ef5d0ffb315c432bdeb325a165c5f64a2e82ff810e40ddf94cc6d2b7d45f7466dd6af713e86a45360a62a605422043bb35e20163d3d306c85e0eba369a6de6ca43c128f7dd092b9e99abbefacd4e90b0ac82114a5e427474b5672300d8b2c2d743aaae8d653eabf5f2e92559da561590ac388b34f3391f5983bb28f54ddee295efd177d0adb015e9a568166de6186e0ee4b0443d3bc1a23d493d2869acf0d5ab6cdaaedf79192026d3f92af403ab77b1adc37832958ee925a829cd67cda59adf20c83d483a057b6b77afd77e6a3dc21bab5aaf81e7cbd48c0fa2ac6e76e59fd6e6649e383ea66dd02be7b8cd8a6f4a7e7d47c33b6fb2b2e406fee8f1b3239fe08fdefc8a6aa0365b074bfe4474aea7350d44ecadc1c7734ccaaa5172358b209b2120c1b69b93a34ef3745903938caea028c019154400de0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">需要密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
